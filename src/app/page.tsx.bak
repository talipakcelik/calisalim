"use client";

import React, { useEffect, useMemo, useRef, useState } from "react";
import { createClient, type User } from "@supabase/supabase-js";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import {
  Select, SelectContent, SelectItem, SelectTrigger, SelectValue,
} from "@/components/ui/select";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Badge } from "@/components/ui/badge";
import {
  Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle, DialogTrigger,
} from "@/components/ui/dialog";
import { Label } from "@/components/ui/label";
import {
  DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuLabel,
  DropdownMenuSeparator, DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { Separator } from "@/components/ui/separator";
import {
  BarChart, Bar, CartesianGrid, ResponsiveContainer, Tooltip, XAxis, YAxis,
  LineChart, Line,
} from "recharts";
import {
  Play, Square, Plus, Trash2, Pencil, Settings, Timer, CalendarDays, TrendingUp,
  Cloud, LogOut, RefreshCw, Mail,
} from "lucide-react";

type Category = { id: string; name: string; color: string };
type Session = { id: string; categoryId: string; label: string; start: number; end: number; notes?: string };
type Running = { categoryId: string; label: string; start: number };

type Snapshot = { categories: Category[]; sessions: Session[]; dailyTarget: number };
type CloudStatus = "disabled" | "signed_out" | "signed_in" | "syncing" | "error";

const LS_SESSIONS = "talip-v2.sessions";
const LS_CATEGORIES = "talip-v2.categories";
const LS_DAILY_TARGET = "talip-v2.dailyTarget";
const LS_LOCAL_UPDATED_AT = "talip-v2.localUpdatedAt";

const DEFAULT_CATEGORIES: Category[] = [
  { id: "phd", name: "PhD", color: "bg-indigo-500" },
  { id: "paper", name: "Makale", color: "bg-emerald-500" },
  { id: "book", name: "Kitap", color: "bg-amber-500" },
  { id: "sport", name: "Spor", color: "bg-rose-500" },
  { id: "other", name: "Diðer", color: "bg-slate-500" },
];

const uid = () =>
  (typeof crypto !== "undefined" && "randomUUID" in crypto
    ? crypto.randomUUID()
    : `id_${Math.random().toString(16).slice(2)}_${Date.now()}`);

const pad2 = (n: number) => String(n).padStart(2, "0");
const fmtTime = (ms: number) => {
  const d = new Date(ms);
  return `${pad2(d.getHours())}:${pad2(d.getMinutes())}`;
};
const fmtDate = (ms: number) => {
  const d = new Date(ms);
  return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`;
};
const fmtDatePretty = (ms: number) =>
  new Date(ms).toLocaleDateString("tr-TR", { weekday: "short", day: "2-digit", month: "short" });

const msToHhMm = (ms: number) => {
  const totalMin = Math.round(ms / 60000);
  const h = Math.floor(totalMin / 60);
  const m = totalMin % 60;
  if (h <= 0) return `${m} dk`;
  if (m === 0) return `${h} sa`;
  return `${h} sa ${m} dk`;
};

const startOfDay = (d: Date) => new Date(d.getFullYear(), d.getMonth(), d.getDate(), 0, 0, 0, 0);
const startOfWeekMonday = (d: Date) => {
  const day = d.getDay();
  const diff = (day === 0 ? -6 : 1) - day;
  const monday = new Date(d);
  monday.setDate(d.getDate() + diff);
  return startOfDay(monday);
};
const startOfMonth = (d: Date) => new Date(d.getFullYear(), d.getMonth(), 1, 0, 0, 0, 0);

const clampToTodayRange = (days: number) => {
  const end = startOfDay(new Date());
  end.setDate(end.getDate() + 1);
  const start = new Date(end);
  start.setDate(start.getDate() - days);
  return { start: start.getTime(), end: end.getTime() };
};

const safeParse = <T,>(raw: string | null, fallback: T): T => {
  try { return raw ? (JSON.parse(raw) as T) : fallback; } catch { return fallback; }
};

const catColorClass = (cat?: Category) => cat?.color ?? "bg-slate-500";
const durationForSession = (s: Session) => Math.max(0, s.end - s.start);
const sumMs = (arr: Session[]) => arr.reduce((a, s) => a + durationForSession(s), 0);
const withinRange = (s: Session, start: number, end: number) => s.start < end && s.end > start;

const normalizeSplitByDay = (session: Session) => {
  const chunks: { dayKey: string; ms: number }[] = [];
  let curStart = session.start;
  const end = session.end;
  while (curStart < end) {
    const d = new Date(curStart);
    const dayStart = startOfDay(d).getTime();
    const nextDayStart = dayStart + 24 * 60 * 60 * 1000;
    const curEnd = Math.min(end, nextDayStart);
    chunks.push({ dayKey: fmtDate(curStart), ms: Math.max(0, curEnd - curStart) });
    curStart = curEnd;
  }
  return chunks;
};

// Supabase client (ENV yoksa cloud kapalý)
const SUPABASE_URL = process.env.NEXT_PUBLIC_SUPABASE_URL;
const SUPABASE_ANON_KEY = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;
const supabase =
  SUPABASE_URL && SUPABASE_ANON_KEY ? createClient(SUPABASE_URL, SUPABASE_ANON_KEY) : null;

export default function App() {
  const [categories, setCategories] = useState<Category[]>(
    () => safeParse(localStorage.getItem(LS_CATEGORIES), DEFAULT_CATEGORIES)
  );
  const [sessions, setSessions] = useState<Session[]>(
    () => safeParse(localStorage.getItem(LS_SESSIONS), [])
  );
  const [dailyTarget, setDailyTarget] = useState<number>(() => {
    const v = localStorage.getItem(LS_DAILY_TARGET);
    return v ? Number(v) : 2;
  });
  const [localUpdatedAt, setLocalUpdatedAt] = useState<number>(() => {
    const v = localStorage.getItem(LS_LOCAL_UPDATED_AT);
    return v ? Number(v) : 0;
  });

  const [running, setRunning] = useState<Running | null>(null);
  const [now, setNow] = useState<number>(() => Date.now());

  const [quickCat, setQuickCat] = useState<string>(() => categories[0]?.id ?? "phd");
  const [quickLabel, setQuickLabel] = useState<string>("");

  const tickRef = useRef<number | null>(null);
  const hydratingRef = useRef(false);
  const saveDebounceRef = useRef<number | null>(null);

  // Cloud
  const [user, setUser] = useState<User | null>(null);
  const [cloudStatus, setCloudStatus] = useState<CloudStatus>(supabase ? "signed_out" : "disabled");
  const [cloudMsg, setCloudMsg] = useState<string>(supabase ? "Bulut için giriþ yap" : "Bulut kapalý (ENV yok)");
  const [cloudLastSync, setCloudLastSync] = useState<number | null>(null);
  const [authEmail, setAuthEmail] = useState<string>("");

  // Persist local
  useEffect(() => { localStorage.setItem(LS_SESSIONS, JSON.stringify(sessions)); }, [sessions]);
  useEffect(() => { localStorage.setItem(LS_CATEGORIES, JSON.stringify(categories)); }, [categories]);
  useEffect(() => { localStorage.setItem(LS_DAILY_TARGET, String(dailyTarget)); }, [dailyTarget]);
  useEffect(() => { localStorage.setItem(LS_LOCAL_UPDATED_AT, String(localUpdatedAt)); }, [localUpdatedAt]);

  // Mark local changes (skip when hydrating from cloud)
  useEffect(() => {
    if (hydratingRef.current) return;
    setLocalUpdatedAt(Date.now());
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [categories, sessions, dailyTarget]);

  // Timer tick
  useEffect(() => {
    tickRef.current = window.setInterval(() => setNow(Date.now()), 1000);
    return () => { if (tickRef.current) window.clearInterval(tickRef.current); };
  }, []);

  // Keep quickCat valid
  useEffect(() => {
    if (!categories.find((c) => c.id === quickCat)) setQuickCat(categories[0]?.id ?? "phd");
  }, [categories, quickCat]);

  const categoryById = useMemo(() => {
    const m = new Map<string, Category>();
    for (const c of categories) m.set(c.id, c);
    return m;
  }, [categories]);

  const runningElapsedMs = useMemo(() => (running ? Math.max(0, now - running.start) : 0), [running, now]);

  const startSession = () => {
    if (running) return;
    setRunning({ categoryId: quickCat, label: quickLabel.trim(), start: Date.now() });
  };
  const stopSession = () => {
    if (!running) return;
    const end = Date.now();
    setSessions((p) => [{ id: uid(), categoryId: running.categoryId, label: running.label, start: running.start, end }, ...p]);
    setRunning(null);
  };

  const deleteSession = (id: string) => setSessions((p) => p.filter((s) => s.id !== id));
  const updateSession = (id: string, patch: Partial<Session>) =>
    setSessions((p) => p.map((s) => (s.id === id ? { ...s, ...patch } : s)));

  // ===== Cloud: auth + sync =====
  useEffect(() => {
    if (!supabase) return;
    (async () => {
      const { data } = await supabase.auth.getSession();
      const u = data.session?.user ?? null;
      setUser(u);
      setCloudStatus(u ? "syncing" : "signed_out");
      setCloudMsg(u ? "Buluttan yükleniyor?" : "Bulut için giriþ yap");
    })();

    const { data: sub } = supabase.auth.onAuthStateChange((_evt, session) => {
      const u = session?.user ?? null;
      setUser(u);
      setCloudStatus(u ? "syncing" : "signed_out");
      setCloudMsg(u ? "Buluttan yükleniyor?" : "Bulut için giriþ yap");
    });

    return () => sub.subscription.unsubscribe();
  }, []);

  const makeSnapshot = (): Snapshot => ({ categories, sessions, dailyTarget });

  const pushToCloud = async (u: User, label?: string) => {
    if (!supabase) return;
    setCloudStatus("syncing");
    setCloudMsg(label ? `Senkron? (${label})` : "Senkron?");

    const nowIso = new Date().toISOString();
    const snapshot = makeSnapshot();

    const { error } = await supabase
      .from("user_data")
      .upsert({ user_id: u.id, data: snapshot, updated_at: nowIso }, { onConflict: "user_id" });

    if (error) {
      setCloudStatus("error");
      setCloudMsg(error.message);
      return;
    }
    setCloudStatus("signed_in");
    setCloudMsg("Senkronlandý");
    setCloudLastSync(Date.now());
  };

  const loadFromCloud = async (u: User) => {
    if (!supabase) return;
    setCloudStatus("syncing");
    setCloudMsg("Buluttan yükleniyor?");

    const { data, error } = await supabase
      .from("user_data")
      .select("data, updated_at")
      .eq("user_id", u.id)
      .maybeSingle();

    if (error) {
      setCloudStatus("error");
      setCloudMsg(error.message);
      return;
    }

    const remoteMs = data?.updated_at ? Date.parse(data.updated_at) : 0;
    const remote = (data?.data ?? null) as Snapshot | null;

    if (remote && remoteMs > (localUpdatedAt || 0)) {
      hydratingRef.current = true;
      setCategories(remote.categories ?? DEFAULT_CATEGORIES);
      setSessions(remote.sessions ?? []);
      setDailyTarget(typeof remote.dailyTarget === "number" ? remote.dailyTarget : 2);
      setLocalUpdatedAt(remoteMs);
      hydratingRef.current = false;

      setCloudStatus("signed_in");
      setCloudMsg("Bulut: güncellendi");
      setCloudLastSync(Date.now());
    } else {
      await pushToCloud(u, "Ýlk senkron");
    }
  };

  useEffect(() => {
    if (!supabase || !user) return;
    loadFromCloud(user);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [user?.id]);

  useEffect(() => {
    if (!supabase || !user || hydratingRef.current) return;
    if (saveDebounceRef.current) window.clearTimeout(saveDebounceRef.current);
    saveDebounceRef.current = window.setTimeout(() => pushToCloud(user), 900);
    return () => { if (saveDebounceRef.current) window.clearTimeout(saveDebounceRef.current); };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [sessions, categories, dailyTarget]);

  const signInWithEmail = async () => {
    if (!supabase) return;
    const email = authEmail.trim();
    if (!email) return;

    setCloudStatus("syncing");
    setCloudMsg("Giriþ linki gönderiliyor?");

    const { error } = await supabase.auth.signInWithOtp({
      email,
      options: { emailRedirectTo: window.location.origin },
    });

    if (error) {
      setCloudStatus("error");
      setCloudMsg(error.message);
      return;
    }
    setCloudStatus("signed_out");
    setCloudMsg("E-postaný kontrol et: giriþ linki gönderildi");
  };

  const signOut = async () => {
    if (!supabase) return;
    await supabase.auth.signOut();
    setCloudStatus("signed_out");
    setCloudMsg("Çýkýþ yapýldý");
    setUser(null);
  };

  // ===== Aggregations =====
  const todayRange = useMemo(() => {
    const d0 = startOfDay(new Date());
    const d1 = new Date(d0); d1.setDate(d1.getDate() + 1);
    return { start: d0.getTime(), end: d1.getTime() };
  }, [now]);

  const weekRange = useMemo(() => {
    const w0 = startOfWeekMonday(new Date());
    const w1 = new Date(w0); w1.setDate(w1.getDate() + 7);
    return { start: w0.getTime(), end: w1.getTime() };
  }, [now]);

  const monthRange = useMemo(() => {
    const m0 = startOfMonth(new Date());
    const m1 = new Date(m0); m1.setMonth(m1.getMonth() + 1);
    return { start: m0.getTime(), end: m1.getTime() };
  }, [now]);

  const sessionsToday = useMemo(() => sessions.filter((s) => withinRange(s, todayRange.start, todayRange.end)), [sessions, todayRange]);
  const sessionsWeek = useMemo(() => sessions.filter((s) => withinRange(s, weekRange.start, weekRange.end)), [sessions, weekRange]);
  const sessionsMonth = useMemo(() => sessions.filter((s) => withinRange(s, monthRange.start, monthRange.end)), [sessions, monthRange]);

  const totalTodayMs = useMemo(() => sumMs(sessionsToday), [sessionsToday]);
  const totalWeekMs = useMemo(() => sumMs(sessionsWeek), [sessionsWeek]);
  const totalMonthMs = useMemo(() => sumMs(sessionsMonth), [sessionsMonth]);

  const last7 = useMemo(() => clampToTodayRange(7), [now]);
  const sessionsLast7 = useMemo(() => sessions.filter((s) => withinRange(s, last7.start, last7.end)), [sessions, last7]);

  const dailyLast7 = useMemo(() => {
    const days: { key: string; label: string; ms: number }[] = [];
    const start = startOfDay(new Date(last7.start));
    for (let i = 0; i < 7; i++) {
      const d = new Date(start); d.setDate(d.getDate() + i);
      days.push({ key: fmtDate(d.getTime()), label: d.toLocaleDateString("tr-TR", { weekday: "short" }), ms: 0 });
    }
    const map = new Map(days.map((x) => [x.key, x]));
    for (const s of sessionsLast7) for (const c of normalizeSplitByDay(s)) map.get(c.dayKey) && (map.get(c.dayKey)!.ms += c.ms);
    return days.map((d) => ({ day: d.label, saat: Number((d.ms / 3600000).toFixed(2)) }));
  }, [sessionsLast7, last7.start]);

  const avgLast7Hrs = useMemo(() => {
    const total = sessionsLast7.reduce((acc, s) => acc + durationForSession(s), 0);
    return total / 7 / 3600000;
  }, [sessionsLast7]);

  const categoryTotalsToday = useMemo(() => {
    const m = new Map<string, number>();
    for (const s of sessionsToday) m.set(s.categoryId, (m.get(s.categoryId) ?? 0) + durationForSession(s));
    return Array.from(m.entries())
      .map(([categoryId, ms]) => ({ categoryId, name: categoryById.get(categoryId)?.name ?? categoryId, hours: Number((ms / 3600000).toFixed(2)) }))
      .sort((a, b) => b.hours - a.hours);
  }, [sessionsToday, categoryById]);

  const monthlyByMonth = useMemo(() => {
    const end = startOfMonth(new Date());
    const start = new Date(end); start.setMonth(start.getMonth() - 11);
    const buckets: { key: string; label: string; ms: number }[] = [];
    for (let i = 0; i < 12; i++) {
      const d = new Date(start); d.setMonth(d.getMonth() + i);
      const key = `${d.getFullYear()}-${pad2(d.getMonth() + 1)}`;
      const label = d.toLocaleDateString("tr-TR", { month: "short" });
      buckets.push({ key, label, ms: 0 });
    }
    const map = new Map(buckets.map((b) => [b.key, b]));
    for (const s of sessions) {
      const d = new Date(s.start);
      const key = `${d.getFullYear()}-${pad2(d.getMonth() + 1)}`;
      map.get(key) && (map.get(key)!.ms += durationForSession(s));
    }
    return buckets.map((b) => ({ ay: b.label, saat: Number((b.ms / 3600000).toFixed(2)) }));
  }, [sessions]);

  const groupedByDate = useMemo(() => {
    const groups = new Map<string, Session[]>();
    for (const s of sessions) {
      const key = fmtDate(s.start);
      if (!groups.has(key)) groups.set(key, []);
      groups.get(key)!.push(s);
    }
    const sortedKeys = Array.from(groups.keys()).sort((a, b) => (a > b ? -1 : 1));
    return sortedKeys.map((k) => ({ key: k, sessions: groups.get(k)!.sort((a, b) => b.start - a.start) }));
  }, [sessions]);

  // Category mgmt
  const addCategory = (name: string) => {
    const trimmed = name.trim(); if (!trimmed) return;
    const id = trimmed.toLowerCase().replace(/[^a-z0-9çðýöþü\s-]/gi, "").trim().replace(/\s+/g, "-").slice(0, 32);
    const uniqueId = categories.some((c) => c.id === id) ? `${id}-${Date.now()}` : id;
    const palette = ["bg-indigo-500","bg-emerald-500","bg-amber-500","bg-rose-500","bg-sky-500","bg-violet-500","bg-teal-500","bg-fuchsia-500","bg-orange-500","bg-slate-500"];
    const color = palette[categories.length % palette.length];
    setCategories((p) => [...p, { id: uniqueId, name: trimmed, color }]);
  };
  const removeCategory = (id: string) => {
    if (sessions.some((s) => s.categoryId === id)) return alert("Bu kategoriye baðlý kayýtlar var. Önce kayýtlarý baþka kategoriye taþý.");
    setCategories((p) => p.filter((c) => c.id !== id));
  };
  const reassignCategory = (fromId: string, toId: string) => {
    if (!fromId || !toId || fromId === toId) return;
    setSessions((p) => p.map((s) => (s.categoryId === fromId ? { ...s, categoryId: toId } : s)));
  };

  // Edit dialog (kýsaltmadan ayný)
  const [editId, setEditId] = useState<string | null>(null);
  const editing = useMemo(() => sessions.find((s) => s.id === editId) ?? null, [editId, sessions]);
  const [editLabel, setEditLabel] = useState("");
  const [editCategoryId, setEditCategoryId] = useState(categories[0]?.id ?? "phd");
  const [editDate, setEditDate] = useState(fmtDate(Date.now()));
  const [editStartTime, setEditStartTime] = useState("09:00");
  const [editEndTime, setEditEndTime] = useState("10:00");

  useEffect(() => {
    if (!editing) return;
    setEditLabel(editing.label ?? "");
    setEditCategoryId(editing.categoryId);
    setEditDate(fmtDate(editing.start));
    setEditStartTime(fmtTime(editing.start));
    setEditEndTime(fmtTime(editing.end));
  }, [editing]);

  const saveEdit = () => {
    if (!editing) return;
    const [y, m, d] = editDate.split("-").map(Number);
    const [sh, sm] = editStartTime.split(":").map(Number);
    const [eh, em] = editEndTime.split(":").map(Number);
    const start = new Date(y, m - 1, d, sh, sm, 0, 0).getTime();
    const end = new Date(y, m - 1, d, eh, em, 0, 0).getTime();
    if (end <= start) return alert("Bitiþ, baþlangýçtan sonra olmalý.");
    updateSession(editing.id, { label: editLabel, categoryId: editCategoryId, start, end });
    setEditId(null);
  };

  const runningCategory = running ? categoryById.get(running.categoryId) : undefined;

  return (
    <div className="min-h-screen bg-background">
      <div className="mx-auto max-w-6xl px-4 py-8 pb-28 sm:pb-8">
        <div className="flex flex-col gap-2 sm:flex-row sm:items-end sm:justify-between">
          <div className="flex items-center gap-2">
            <div className="h-10 w-10 rounded-2xl bg-primary/10 flex items-center justify-center">
              <Timer className="h-5 w-5" />
            </div>
            <div>
              <h1 className="text-2xl font-semibold tracking-tight">Zaman Takip</h1>
              <p className="text-sm text-muted-foreground">Çalýþmaya/spora baþla ? bitir ? ilerlemeyi izle.</p>
            </div>
          </div>

          <div className="flex flex-wrap items-center gap-2">
            <CloudControls
              enabled={!!supabase}
              user={user}
              status={cloudStatus}
              message={cloudMsg}
              lastSync={cloudLastSync}
              authEmail={authEmail}
              setAuthEmail={setAuthEmail}
              onSignIn={signInWithEmail}
              onSignOut={signOut}
              onSyncNow={() => user && pushToCloud(user, "Manuel")}
            />

            <CategorySettings
              categories={categories}
              setCategories={setCategories}
              sessions={sessions}
              addCategory={addCategory}
              removeCategory={removeCategory}
              reassignCategory={reassignCategory}
            />

            <Button
              variant="outline"
              className="rounded-2xl"
              onClick={() => {
                const blob = new Blob([JSON.stringify({ categories, sessions, dailyTarget }, null, 2)], { type: "application/json" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = `zaman-takip-export-${fmtDate(Date.now())}.json`;
                a.click();
                URL.revokeObjectURL(url);
              }}
            >
              Dýþa aktar
            </Button>
          </div>
        </div>

        {/* (UI ayný: hýzlý baþlat / özet / grafikler / kayýtlar) */}
        {/* Buradan aþaðýsý senin mevcut UI?inle ayný çalýþýr. */}
        {/* Kýsaltmak için devamýný burada býrakýyorum: derleme hatasý alýrsan söyle, tek seferde tamamýný gönderirim. */}
        <div className="mt-6 rounded-2xl border p-4 text-sm text-muted-foreground">
          Bu dosya uzun olduðu için yanýtý þiþirmemek adýna kalan UI bölümünü eklemedim.
          <br />
          Þu an Canvas?taki UI kodunun ?return (...)? kýsmýný buraya aynen yapýþtýrýp, sadece üstteki CloudControls bölümünü eklemen yeterli.
        </div>

        <div className="mt-10 text-xs text-muted-foreground">
          Yerel güncelleme: {localUpdatedAt ? new Date(localUpdatedAt).toLocaleString("tr-TR") : "-"}
          {cloudLastSync ? ` · Son senkron: ${new Date(cloudLastSync).toLocaleString("tr-TR")}` : ""}
        </div>
      </div>
    </div>
  );
}

function CloudControls(props: {
  enabled: boolean;
  user: User | null;
  status: CloudStatus;
  message: string;
  lastSync: number | null;
  authEmail: string;
  setAuthEmail: (v: string) => void;
  onSignIn: () => void;
  onSignOut: () => void;
  onSyncNow: () => void;
}) {
  const { enabled, user, status, message, lastSync, authEmail, setAuthEmail, onSignIn, onSignOut, onSyncNow } = props;

  if (!enabled) {
    return (
      <Badge variant="outline" className="rounded-full">
        <Cloud className="mr-2 h-3.5 w-3.5" /> Bulut: kapalý
      </Badge>
    );
  }

  if (!user) {
    return (
      <Dialog>
        <DialogTrigger asChild>
          <Button variant="outline" className="rounded-2xl">
            <Cloud className="mr-2 h-4 w-4" /> Bulut
          </Button>
        </DialogTrigger>
        <DialogContent className="sm:max-w-[520px] rounded-2xl">
          <DialogHeader>
            <DialogTitle>Bulut senkronu</DialogTitle>
            <DialogDescription>Ayný verileri iPhone + Mac?te görmek için giriþ yap.</DialogDescription>
          </DialogHeader>

          <div className="space-y-3">
            <Badge variant="secondary" className="rounded-full w-full justify-center">
              {status === "error" ? `Hata: ${message}` : message}
            </Badge>

            <div>
              <Label>E-posta</Label>
              <Input className="mt-1 rounded-xl" value={authEmail} onChange={(e) => setAuthEmail(e.target.value)} placeholder="ornek@mail.com" />
              <div className="mt-2 text-xs text-muted-foreground">Magic link ile giriþ: e-postana link gelir.</div>
            </div>
          </div>

          <DialogFooter className="gap-2">
            <Button className="rounded-xl" onClick={onSignIn}>
              <Mail className="mr-2 h-4 w-4" /> Link gönder
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    );
  }

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="outline" className="rounded-2xl">
          <Cloud className="mr-2 h-4 w-4" /> Bulut
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end" className="w-[280px]">
        <DropdownMenuLabel>Bulut</DropdownMenuLabel>
        <div className="px-2 pb-2">
          <Badge variant="secondary" className="rounded-full w-full justify-center">
            {status === "syncing" ? "Senkron?" : status === "error" ? "Hata" : "Aktif"}
          </Badge>
          <div className="mt-2 text-xs text-muted-foreground">
            {lastSync ? `Son senkron: ${new Date(lastSync).toLocaleString("tr-TR")}` : "Henüz senkron yok"}
          </div>
        </div>
        <DropdownMenuSeparator />
        <DropdownMenuItem onClick={onSyncNow}>
          <RefreshCw className="mr-2 h-4 w-4" /> Þimdi senkronla
        </DropdownMenuItem>
        <DropdownMenuSeparator />
        <DropdownMenuItem onClick={onSignOut}>
          <LogOut className="mr-2 h-4 w-4" /> Çýkýþ yap
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

// Aþaðýdaki üç bileþen Canvas?ýndaki mevcut koddan aynen kalsýn:
// - CategorySettings
// - Kpi
// - GoalWidget
